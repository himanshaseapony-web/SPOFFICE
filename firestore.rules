rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function getUserProfileExists() {
      return exists(/databases/$(database)/documents/userProfiles/$(request.auth.uid));
    }
    
    function getUserProfileOrNull() {
      return exists(/databases/$(database)/documents/userProfiles/$(request.auth.uid)) 
             ? get(/databases/$(database)/documents/userProfiles/$(request.auth.uid)).data 
             : null;
    }
    
    function hasRole(roles) {
      return isAuthenticated() && 
             getUserProfileExists() && 
             getUserProfileOrNull() != null &&
             getUserProfileOrNull().role in roles;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isAssigned(taskData) {
      return isAuthenticated() && request.auth.uid == taskData.assigneeId;
    }
    
    function isCreator(taskData) {
      return isAuthenticated() && 
             'createdBy' in taskData && 
             request.auth.uid == taskData.createdBy;
    }
    
    // Check if user is assigned to a specific department in calendar update
    function isAssignedToDepartment(updateData, department) {
      return isAuthenticated() &&
             'assignees' in updateData &&
             updateData.assignees is list &&
             updateData.assignees.hasAny([{
               'id': request.auth.uid,
               'department': department
             }]);
    }
    
    function isCurrentUserAdmin() {
      let profile = getUserProfileOrNull();
      return isAuthenticated() && 
             getUserProfileExists() && 
             profile != null && 
             profile.role == 'Admin';
    }
    
    // User Profiles
    match /userProfiles/{userId} {
      allow read: if isAuthenticated();
      // Allow create if:
      // 1. User is creating their own profile (during initial signup)
      // 2. Admin is creating a profile for another user
      allow create: if isAuthenticated() && (
        isOwner(userId) || 
        isCurrentUserAdmin()
      );
      
      // Allow update if:
      // 1. User is updating their own profile (for profile image, display name, etc. - but not role/department/isDepartmentHead)
      // 2. Admin is updating any user's profile (including role changes)
      allow update: if isAuthenticated() && (
        // Owner updating own profile (restricted fields - cannot change role, department, or isDepartmentHead)
        (isOwner(userId) && 
         (!('role' in request.resource.data.diff(resource.data).affectedKeys()) || 
          request.resource.data.role == resource.data.role) &&
         (!('isDepartmentHead' in request.resource.data.diff(resource.data).affectedKeys()) || 
          request.resource.data.isDepartmentHead == resource.data.isDepartmentHead) &&
         (!('department' in request.resource.data.diff(resource.data).affectedKeys()) || 
          request.resource.data.department == resource.data.department)) ||
        // Admin can update any user's profile (including role, department, isDepartmentHead)
        isCurrentUserAdmin()
      );
      
      // Allow delete only for Admins
      allow delete: if isAuthenticated() && hasRole(['Admin']);
    }
    
    // Departments
    match /departments/{departmentId} {
      allow read: if isAuthenticated();
      allow create, update, delete: if isAuthenticated() && hasRole(['Admin', 'Manager']);
    }
    
    // Tasks
    match /tasks/{taskId} {
      // Allow read for authenticated users - filtering happens client-side
      allow read: if isAuthenticated();
      
      // Managers have full access to all departments (department = "all")
      allow create: if isAuthenticated() && 
        getUserProfileExists() &&
        hasRole(['Admin', 'Manager', 'Specialist', 'DepartmentHead']) &&
        request.resource.data.keys().hasAll(['title', 'department', 'assignee', 'status', 'priority', 'summary']) &&
        request.resource.data.title is string &&
        request.resource.data.department is string &&
        request.resource.data.assignee is string &&
        request.resource.data.status is string &&
        request.resource.data.priority is string &&
        request.resource.data.summary is string &&
        // fileUrls is optional, but if present must be a list of strings
        (!('fileUrls' in request.resource.data) || 
         (request.resource.data.fileUrls is list && 
          request.resource.data.fileUrls.size() <= 50));
      
      allow update: if isAuthenticated() && getUserProfileExists() && (
        // Can update if assigned to the task (can update status, priority, summary, fileUrls, completedAt, dueDate)
        // This includes when a user creates a task and assigns it to themselves
        (isAssigned(resource.data) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'priority', 'summary', 'fileUrls', 'completedAt', 'dueDate', 'updatedAt'])) ||
        // Admin/Manager can update any field (Managers have department = "all" for full access)
        hasRole(['Admin', 'Manager']) ||
        // Department heads can update tasks in their department
        (getUserProfileOrNull() != null && 
         getUserProfileOrNull().isDepartmentHead == true &&
         getUserProfileOrNull().department == resource.data.department) ||
        // Or if updating status/priority and assigned to same department
        (getUserProfileOrNull() != null && 
         getUserProfileOrNull().department == resource.data.department && 
         hasRole(['Specialist']) &&
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'priority', 'summary', 'completedAt', 'dueDate', 'updatedAt']))
      );
      
      allow delete: if isAuthenticated() && hasRole(['Admin']);
    }
    
    // Department Chats
    match /departmentChats/{messageId} {
      // Allow read for authenticated users - filtering happens client-side
      allow read: if isAuthenticated();
      
      allow create: if isAuthenticated() &&
        request.resource.data.authorId == request.auth.uid &&
        request.resource.data.keys().hasAll(['author', 'authorId', 'department', 'text', 'createdAt', 'role']);
      
      allow update, delete: if isAuthenticated() && (
        isOwner(resource.data.authorId) ||
        hasRole(['Admin', 'Manager'])
      );
    }
    
    // Company Chat - accessible to all authenticated users
    match /companyChats/{messageId} {
      // Allow read for all authenticated users
      allow read: if isAuthenticated();
      
      // Allow create for all authenticated users (must be the author)
      allow create: if isAuthenticated() &&
        request.resource.data.authorId == request.auth.uid &&
        request.resource.data.keys().hasAll(['author', 'authorId', 'text', 'createdAt', 'role']);
      
      // Allow update for:
      // 1. Author or Admin/Manager (full update)
      // 2. Any authenticated user (to update seenBy field only - they can only add themselves)
      allow update: if isAuthenticated() && (
        // Full update by author or Admin/Manager
        (isOwner(resource.data.authorId) || hasRole(['Admin', 'Manager'])) ||
        // Limited update: only seenBy field by any authenticated user
        // The backend function ensures users can only add themselves
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['seenBy'])
      );
      
      // Allow delete only by the author or Admin/Manager
      allow delete: if isAuthenticated() && (
        isOwner(resource.data.authorId) ||
        hasRole(['Admin', 'Manager'])
      );
    }
    
    // Calendar Updates - monthly deadline tracking
    match /calendarUpdates/{updateId} {
      // Allow read for all authenticated users
      allow read: if isAuthenticated();
      
      // Allow create for Admin, Manager, and Department Heads
      allow create: if isAuthenticated() &&
        getUserProfileExists() &&
        hasRole(['Admin', 'Manager', 'DepartmentHead']) &&
        request.resource.data.keys().hasAll(['month', 'year', 'taskDetails', 'assignees', 'createdBy', 'createdByName', 'createdAt']) &&
        request.resource.data.month is string &&
        request.resource.data.month.size() > 0 &&
        request.resource.data.year is int &&
        request.resource.data.year >= 2020 &&
        request.resource.data.year <= 2100 &&
        // deadline is optional (for backward compatibility), but if present must be string
        (!('deadline' in request.resource.data) || request.resource.data.deadline is string) &&
        // departmentDeadlines is optional, but if present must be a map
        (!('departmentDeadlines' in request.resource.data) || 
         (request.resource.data.departmentDeadlines is map &&
          request.resource.data.departmentDeadlines.size() > 0 &&
          request.resource.data.departmentDeadlines.size() <= 20)) &&
        request.resource.data.taskDetails is string &&
        request.resource.data.taskDetails.size() > 0 &&
        request.resource.data.assignees is list &&
        request.resource.data.assignees.size() > 0 &&
        request.resource.data.assignees.size() <= 50 &&
        request.resource.data.createdBy == request.auth.uid;
      
      // Allow update for Admin, Manager, and the creator
      // Can update deadline, departmentDeadlines, departmentStatuses, overallStatus, taskDetails, assignees, and updatedAt
      allow update: if isAuthenticated() && (
        // Admin/Manager can update any allowed field
        hasRole(['Admin', 'Manager']) ||
        // Task creator (owner) can update any allowed field including departmentStatuses
        isOwner(resource.data.createdBy) ||
        // Allow specialists/department heads to update their assigned department's status only
        // They must be in the assignees list (either as creator who assigned themselves, or assigned by Admin/Manager)
        (hasRole(['Specialist', 'DepartmentHead']) &&
         // Only allow updating departmentStatuses, overallStatus, and updatedAt
         request.resource.data.diff(resource.data).affectedKeys().hasOnly(['departmentStatuses', 'overallStatus', 'updatedAt']) &&
         request.resource.data.departmentStatuses is map &&
         request.resource.data.departmentStatuses.size() <= 20 &&
         // Verify user is in the assignees list (check if their ID exists in any assignee object)
         'assignees' in resource.data &&
         resource.data.assignees is list &&
         resource.data.assignees.size() > 0 &&
         // Check if user's ID exists in the assignees array
         // Note: Firestore rules can't easily check nested fields, so we allow if user is Specialist/DepartmentHead
         // The frontend will enforce the department-specific assignment check
         true)
      ) &&
        // Only allow updates to specific fields (applies to all users)
        (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['deadline', 'departmentDeadlines', 'departmentStatuses', 'overallStatus', 'taskDetails', 'assignees', 'updatedAt']) ||
         // Or if updating only departmentDeadlines and updatedAt
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['departmentDeadlines', 'updatedAt']) &&
          request.resource.data.departmentDeadlines is map &&
          request.resource.data.departmentDeadlines.size() > 0 &&
          request.resource.data.departmentDeadlines.size() <= 20) ||
         // Or if updating only departmentStatuses, overallStatus, and updatedAt
         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['departmentStatuses', 'overallStatus', 'updatedAt']) &&
          request.resource.data.departmentStatuses is map &&
          request.resource.data.departmentStatuses.size() <= 20)) &&
        // Preserve required fields
        request.resource.data.month == resource.data.month &&
        request.resource.data.year == resource.data.year &&
        request.resource.data.createdBy == resource.data.createdBy &&
        request.resource.data.createdByName == resource.data.createdByName &&
        request.resource.data.createdAt == resource.data.createdAt;
      
      // Allow delete for Admin, Manager, and the creator
      allow delete: if isAuthenticated() && (
        hasRole(['Admin', 'Manager']) ||
        isOwner(resource.data.createdBy)
      );
    }
    
    // Calendar Status Notifications - approval requests
    match /calendarStatusNotifications/{notificationId} {
      // Allow read for all authenticated users
      allow read: if isAuthenticated();
      
      // Allow create for authenticated users (when requesting approval)
      allow create: if isAuthenticated() &&
        request.resource.data.keys().hasAll(['updateId', 'department', 'requestedBy', 'requestedByName', 'requestedAt', 'status']) &&
        request.resource.data.updateId is string &&
        request.resource.data.department is string &&
        request.resource.data.requestedBy == request.auth.uid &&
        request.resource.data.status == 'pending';
      
      // Allow update for Admin and Manager (to approve/reject)
      allow update: if isAuthenticated() &&
        hasRole(['Admin', 'Manager']) &&
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'reviewedBy', 'reviewedAt']) &&
        request.resource.data.status in ['approved', 'rejected'];
      
      // Allow delete for Admin and Manager
      allow delete: if isAuthenticated() && hasRole(['Admin', 'Manager']);
    }
    
    // KPI Points - track user performance points
    match /kpiPoints/{userId} {
      // Allow read for authenticated users (Managers and Admins can see all, others see their own)
      allow read: if isAuthenticated() && (
        hasRole(['Admin', 'Manager']) ||
        isOwner(userId)
      );
      
      // Allow create/update only by system (when calendar updates are completed)
      // This should be done by Managers/Admins when approving calendar updates or resetting
      allow create, update: if isAuthenticated() &&
        getUserProfileExists() &&
        hasRole(['Admin', 'Manager']) &&
        request.resource.data.keys().hasAll(['userId', 'userName', 'points', 'lastUpdated']) &&
        request.resource.data.userId is string &&
        request.resource.data.userName is string &&
        request.resource.data.points is int &&
        request.resource.data.points >= 0 &&
        request.resource.data.lastUpdated is string &&
        // Allow optional reset fields for admin reset operations
        (!('resetAt' in request.resource.data) || request.resource.data.resetAt is string) &&
        (!('resetBy' in request.resource.data) || request.resource.data.resetBy is string) &&
        (!('resetByName' in request.resource.data) || request.resource.data.resetByName is string);
      
      // Allow delete only by Admins
      allow delete: if isAuthenticated() && hasRole(['Admin']);
    }
    
    // KPI Point History - audit trail of all point awards and reversals
    match /kpiPointHistory/{historyId} {
      // Allow read for authenticated users (Managers and Admins can see all, others see their own)
      allow read: if isAuthenticated() && (
        hasRole(['Admin', 'Manager']) ||
        (request.auth.uid != null && 
         get(/databases/$(database)/documents/kpiPointHistory/$(historyId)).data.userId == request.auth.uid)
      );
      
      // Allow create only by Managers/Admins when awarding points OR creating reversal/reset records
      allow create: if isAuthenticated() &&
        getUserProfileExists() &&
        hasRole(['Admin', 'Manager']) &&
        request.resource.data.keys().hasAll(['userId', 'userName', 'points', 'reason', 'updateId', 'department', 'month', 'year', 'taskDetails', 'awardedAt']) &&
        request.resource.data.userId is string &&
        request.resource.data.userName is string &&
        request.resource.data.points is int &&
        // Allow both positive (awards) and negative (reversals/resets) points
        (request.resource.data.points > 0 || request.resource.data.points < 0 || request.resource.data.points == 0) &&
        request.resource.data.reason is string &&
        request.resource.data.updateId is string &&
        request.resource.data.department is string &&
        request.resource.data.month is string &&
        request.resource.data.year is int &&
        request.resource.data.taskDetails is string &&
        request.resource.data.awardedAt is timestamp &&
        // Reversal records have additional fields
        (!('originalAwardId' in request.resource.data) || request.resource.data.originalAwardId is string) &&
        (!('reversedAt' in request.resource.data) || request.resource.data.reversedAt is string) &&
        // Reset records have additional fields
        (!('resetBy' in request.resource.data) || request.resource.data.resetBy is string) &&
        (!('resetByName' in request.resource.data) || request.resource.data.resetByName is string) &&
        (!('resetAt' in request.resource.data) || request.resource.data.resetAt is string) &&
        (!('previousPoints' in request.resource.data) || request.resource.data.previousPoints is int);
      
      // Allow delete only by Admins
      allow delete: if isAuthenticated() && hasRole(['Admin']);
      
      // No updates allowed - history is immutable
      allow update: if false;
    }
    
    // Daily Work Updates - created by department heads
    match /dailyWorkUpdates/{updateId} {
      // Helper function to check if user is a department head (by flag or role)
      function isDepartmentHead() {
        let profile = getUserProfileOrNull();
        return isAuthenticated() && 
               getUserProfileExists() && 
               profile != null && 
               (profile.isDepartmentHead == true || profile.role == 'DepartmentHead');
      }
      
      // Allow read for authenticated users (department heads can read their department's updates, Admins/Managers can read all)
      allow read: if isAuthenticated();
      
      // Allow create only by department heads for their own department
      allow create: if isAuthenticated() &&
        getUserProfileExists() &&
        getUserProfileOrNull() != null &&
        isDepartmentHead() &&
        request.resource.data.createdBy == request.auth.uid &&
        request.resource.data.department == getUserProfileOrNull().department &&
        request.resource.data.department != 'all' &&
        request.resource.data.keys().hasAll(['date', 'department', 'createdBy', 'createdByName', 'createdAt', 'members']) &&
        request.resource.data.date is string &&
        request.resource.data.date.size() == 10 && // YYYY-MM-DD format
        request.resource.data.department is string &&
        request.resource.data.department.size() > 0 &&
        request.resource.data.createdBy is string &&
        request.resource.data.createdByName is string &&
        request.resource.data.createdByName.size() > 0 &&
        request.resource.data.members is list &&
        request.resource.data.members.size() > 0 &&
        request.resource.data.members.size() <= 50;
        // Note: Detailed validation of members array structure is handled client-side
        // Firestore rules have limitations on validating nested array structures
      
      // Allow update only by the creator or Admin/Manager (with same validation as create)
      allow update: if isAuthenticated() && (
        (isOwner(resource.data.createdBy) || hasRole(['Admin', 'Manager'])) &&
        getUserProfileExists() &&
        getUserProfileOrNull() != null &&
        request.resource.data.keys().hasAll(['date', 'department', 'createdBy', 'createdByName', 'createdAt', 'members']) &&
        request.resource.data.date is string &&
        request.resource.data.date.size() == 10 &&
        request.resource.data.department is string &&
        request.resource.data.department.size() > 0 &&
        request.resource.data.createdBy is string &&
        request.resource.data.createdByName is string &&
        request.resource.data.createdByName.size() > 0 &&
        request.resource.data.members is list &&
        request.resource.data.members.size() > 0 &&
        request.resource.data.members.size() <= 50
      );
      
      // Allow delete only by the creator or Admin/Manager
      allow delete: if isAuthenticated() && (
        isOwner(resource.data.createdBy) ||
        hasRole(['Admin', 'Manager'])
      );
    }
    
    // Default: deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
}

